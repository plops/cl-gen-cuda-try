#include <complex.h>
#include <stdio.h>
complex *fun(complex *__restrict__ a) {
  {
    static complex x[(4 * 4)] = {0.0fi};
    // split 1d into col major n1 x n2 matrix, n1 columns, n2 rows;
    x[(0 + (4 * 0))] = a[0];
    x[(0 + (4 * 1))] = a[1];
    x[(0 + (4 * 2))] = a[2];
    x[(0 + (4 * 3))] = a[3];
    x[(1 + (4 * 0))] = a[4];
    x[(1 + (4 * 1))] = a[5];
    x[(1 + (4 * 2))] = a[6];
    x[(1 + (4 * 3))] = a[7];
    x[(2 + (4 * 0))] = a[8];
    x[(2 + (4 * 1))] = a[9];
    x[(2 + (4 * 2))] = a[10];
    x[(2 + (4 * 3))] = a[11];
    x[(3 + (4 * 0))] = a[12];
    x[(3 + (4 * 1))] = a[13];
    x[(3 + (4 * 2))] = a[14];
    x[(3 + (4 * 3))] = a[15];
    // dft on each row;
    {
      static complex s[(4 * 4)] = {0.0fi};
      const complex w_1_4 = ((1.e+0) + (0.0e+0i));
      const complex w_0_1 = ((0.0e+0) + (-1.e+0i));
      const complex w_3_4 = ((-1.e+0) + (0.0e+0i));
      const complex w_1_2 = ((0.0e+0) + (1.e+0i));
      s[0] = (x[0] + x[4] + x[8] + x[12]);
      s[1] = (x[1] + x[5] + x[9] + x[13]);
      s[2] = (x[2] + x[6] + x[10] + x[14]);
      s[3] = (x[3] + x[7] + x[11] + x[15]);
      s[4] = (x[0] + (x[4] * w_0_1) + (x[8] * w_3_4) + (x[12] * w_1_2));
      s[5] = (x[1] + (x[5] * w_0_1) + (x[9] * w_3_4) + (x[13] * w_1_2));
      s[6] = (x[2] + (x[6] * w_0_1) + (x[10] * w_3_4) + (x[14] * w_1_2));
      s[7] = (x[3] + (x[7] * w_0_1) + (x[11] * w_3_4) + (x[15] * w_1_2));
      s[8] = (x[0] + (x[4] * w_3_4) + (x[8] * w_1_4) + (x[12] * w_3_4));
      s[9] = (x[1] + (x[5] * w_3_4) + (x[9] * w_1_4) + (x[13] * w_3_4));
      s[10] = (x[2] + (x[6] * w_3_4) + (x[10] * w_1_4) + (x[14] * w_3_4));
      s[11] = (x[3] + (x[7] * w_3_4) + (x[11] * w_1_4) + (x[15] * w_3_4));
      s[12] = (x[0] + (x[4] * w_1_2) + (x[8] * w_3_4) + (x[12] * w_0_1));
      s[13] = (x[1] + (x[5] * w_1_2) + (x[9] * w_3_4) + (x[13] * w_0_1));
      s[14] = (x[2] + (x[6] * w_1_2) + (x[10] * w_3_4) + (x[14] * w_0_1));
      s[15] = (x[3] + (x[7] * w_1_2) + (x[11] * w_3_4) + (x[15] * w_0_1));
      // transpose and elementwise multiplication;
      {
        static complex z[(4 * 4)] = {0.0fi};
        const complex wn_p0 = ((1.e+0) + (-0.0e+0i));
        const complex wn_m225 =
            ((9.238795325112866e-1) + (-3.826834323650897e-1i));
        const complex wn_m450 =
            ((7.071067811865475e-1) + (-7.071067811865475e-1i));
        const complex wn_m675 =
            ((3.826834323650898e-1) + (-9.238795325112866e-1i));
        const complex wn_m900 = ((6.123233995736767e-17) + (-1.e+0i));
        const complex wn_m1350 =
            ((-7.071067811865475e-1) + (-7.071067811865475e-1i));
        const complex wn_p1575 =
            ((-9.238795325112867e-1) + (3.8268343236508967e-1i));
        z[0] = s[0];
        z[1] = s[4];
        z[2] = s[8];
        z[3] = s[12];
        z[4] = s[1];
        z[5] = (s[5] * ((9.238795325112866e-1) + (-3.826834323650897e-1i)));
        z[6] = (s[9] * ((7.071067811865475e-1) + (-7.071067811865475e-1i)));
        z[7] = (s[13] * ((3.826834323650898e-1) + (-9.238795325112866e-1i)));
        z[8] = s[2];
        z[9] = (s[6] * ((7.071067811865475e-1) + (-7.071067811865475e-1i)));
        z[10] = (s[10] * ((6.123233995736767e-17) + (-1.e+0i)));
        z[11] = (s[14] * ((-7.071067811865475e-1) + (-7.071067811865475e-1i)));
        z[12] = s[3];
        z[13] = (s[7] * ((3.826834323650898e-1) + (-9.238795325112866e-1i)));
        z[14] = (s[11] * ((-7.071067811865475e-1) + (-7.071067811865475e-1i)));
        z[15] = (s[15] * ((-9.238795325112867e-1) + (3.8268343236508967e-1i)));
        return z;
      }
    }
  }
}
complex global_a[(4 * 4)];

int main() {
  fun(global_a);
  return 0;
}